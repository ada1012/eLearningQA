\apendice{Documentación técnica de programación}

\section{Introducción}
En este apéndice se describe una serie de detalles sobre la programación de la aplicación para que sirvan de ayuda a futuros programadores que utilicen el proyecto. Contiene la estructura de directorios del proyecto en la que se explica el contenido de cada uno, un manual del programador que explica ciertos aspectos que puedan ser de ayuda, los detalles sobre la compilación, instalación, y ejecución en un entorno de desarrollo integrado, y por último, qué pruebas del sistema se han realizado.
En esta segunda versión se dejará el manual tal y como estaba en la primera versión ya que explica correctamente gran parte de la aplicación y se incluirán los cambios oportunos.
\section{Estructura de directorios}
El repositorio está organizado de la siguiente manera:
\begin{itemize}
	\item \textbf{/}: Contiene el README y un .gitignore que evita que se suban los archivos de configuración del IDE al repositorio.
	\item \textbf{/.github/workflows}: Contiene el archivo que establece las tareas de integración continua.
	Las tareas son: instalar Java en la maquina que realiza las tareas, almacenar paquetes de SonarCloud en la caché, almacenar paquetes de Maven en la caché, montar (compilar, ejecutar tests y empaquetar) con maven y analizar con SonarCloud.
	\item \textbf{/Memo/plantillaLatex-master}: Contiene la memoria y los anexos.
	\item \textbf{/Memo/plantillaLatex-master/img}: Contiene las imágenes a usar en memoria y anexos.
	\item \textbf{/Memo/plantillaLatex-master/tex}: Contiene los apartados en formato \LaTeX usados de la memoria y anexos.
	\item \textbf{/Project/prototipo}: Contiene el proyecto de la aplicación web.
	\item \textbf{/Project/prototipo/configurations}: Contiene los archivos de propiedades.
	\item \textbf{/Project/prototipo/src}: Contiene el código fuente de la aplicación.
	\item \textbf{/Project/prototipo/src/main}: Contiene el código, los test, y los recursos que utiliza la aplicación.
	\item \textbf{/Project/prototipo/src/main/java/es/ubu/lsi}: Contiene las clases necesarias para el funcionamiento de la aplicación.
	\item \textbf{/Project/prototipo/src/main/java/es/ubu/lsi/model}: Contiene clases Java Bean para poder deserializar los datos extraídos por medio de servicios web. Junto con otras clases de Java que se han utilizado como modelos para poder trabajar con los datos manipulados previamente obtenidos de los servicios web.
	\item \textbf{/Project/prototipo/src/main/resources}: Contiene el archivo de propiedades de la aplicación web y otros recursos.
	\item \textbf{/Project/prototipo/src/main/resources/images}: Contiene las imágenes a mostrar en la aplicación web.
	\item \textbf{/Project/prototipo/src/main/resources/json}: Contiene información de cursos en formato json para usarla en los tests.
	\item \textbf{/Project/prototipo/src/main/resources/json/informe}: Contiene los textos estáticos de la tabla del informe de fases en formato json.
	\item \textbf{/Project/prototipo/src/main/resources/static/js}: Contiene las librerías JavaScript que utiliza la aplicación.
	\item \textbf{/Project/prototipo/src/main/webapp/WEB-INF/jsp}: Contiene las páginas de la aplicación en formato jsp.
	\item \textbf{/Project/prototipo/src/test/java/es/ubu/lsi}: Contiene los test sobre las consultas que realiza la aplicación en los cursos.
	\item \textbf{/Project/prototipo/target}: Es el directorio donde Maven deposita los resultados, como las clases compiladas y la aplicación compilada en formato WAR.
	
\end{itemize}
\section{Manual del programador}
\subsection{Entorno}
Para trabajar en el proyecto se necesita:
\begin{itemize}
	\item Java JDK 8
	\item Un IDE como puede ser Eclipse, NetBeans o IntelliJ IDEA
\end{itemize}

JDK 8 se puede descargar desde \url{https://www.oracle.com/java/technologies/downloads/#java8} si se está en posesión de una cuenta de Oracle.

En este caso como se ha trabajado con eclipse adjunto el enlace de la descarga \url{https://www.eclipse.org/downloads/}

\subsection{Obtención del código fuente}
Para obtener el código fuente de la aplicación web solo vamos a necesitar clonar el proyecto en nuestro equipo o en el caso de eclipse dentro del propio IDE en la versión importar proyecto Git. El enlace al proyecto es \url{https://github.com/ada1012/eLearningQA}. Si tenemos intención de hacer cambios en la aplicación, antes de clonar el proyecto deberemos hacer un fork para así tener una copia en nuestro perfil de dicho proyecto. En mi caso al manejar git con la extensión de Visual Studio Code puedo manejar los pull, push y commits desde la interfaz gráfica.
\imagen{GitVSCode.png}{Manejo de Git con Visual Studio Code}
\subsection{Propósito de las clases principales}
\begin{itemize}
	\item \textbf{Application:} es la clase principal de la aplicación, arranca la aplicación web.
	\item \textbf{SpringController:} indica mediante anotaciones y funciones qué devolver cuando el usuario accede a cada página. En este caso solo devuelve páginas jsp e imágenes, pero se podrían devolver otros tipos de recurso, como archivos de audio o documentos.
	\item \textbf{ELearningQAFacade:} hace de intermediario entre el usuario y la clase WebServiceClient.También contiene funciones para generar tablas y sus contenidos a partir de la información obtenida. 
	\item \textbf{WebServiceClient:} contiene el código de las comprobaciones y realiza las llamadas REST al servidor de Moodle para obtener la información necesaria. También trabajará con los datos obtenidos de Moodle para adaptarlos a las estadísticas de cuestionarios y foros.
	\item \textbf{FacadeConfig:} almacena la configuración elegida por el usuario junto con el host de Moodle y se guarda como atributo de la fachada para poder pasarlo a las funciones de WebServiceClient y que pueda cambiar su comportamiento según la configuración.
	\item \textbf{AlertLog:} genera y almacena mensajes de alerta, se pasa como parámetro a las funciones de WebServiceClient para que puedan almacenar los mensajes para la lista de mejoras del informe.
	\item \textbf{RegistryIO:} se encarga de almacenar y acceder a la información guardada en csv utilizada para generar los gráficos. También contiene una función que genera un gráfico a partir de los datos de un csv.
	\item \textbf{AnalysisSnapshot:} la clase que representa el conjunto de datos almacenado en cada línea de los archivos csv, facilita el trabajo de almacenamiento de datos y generación de gráficos.
\end{itemize}
\subsection{Integración continua}
El proyecto contiene un archivo llamado \texttt{maven.yml} en \texttt{/.github/workflows} en el que se indica los pasos a seguir tras realizar un \textit{push} a la rama develop del repositorio. Vamos a explicarlos brevemente. \imagen{MavenYML.png}{Trabajos de integración continua}
Lo primero que se puede apreciar es que la máquina virtual que se encarga de la integración continua utiliza la versión más reciente de Ubuntu. Después, se instala JDK 11 (antes se utilizaba JDK 8 para la integración continua, pero tras añadir SonarCloud al proceso, JDK 11 pasó a ser necesario), luego se almacenan en la memoria caché de la máquina virtual los paquetes de SonarCloud y Maven. Finalmente, se construye y analiza el proyecto, se indica la ubicación del archivo \texttt{pom.xml} debido a que el directorio raíz del proyecto no coincide con el del repositorio (después veremos otro problema causado por esto).
\subsection{Herramienta de calidad de código}
Para analizar la calidad del código del proyecto se ha utilizado SonarCloud como se hizo en el trabajo anterior.

La página principal resume el estado del proyecto respecto a errores, \textit{code smells}, seguridad, y cantidad de código duplicado. También muestra el estado del proyecto según el \textit{Quality Gate}, que indica si se cumple una serie de condiciones establecidas.
\imagen{SonarCloud.png}{Página del proyecto en SonarCloud en \url{https://sonarcloud.io/project/overview?id=ada1012_eLearningQA}}
Con esta herramienta se consigue una refactorización inmediata ya que cada vez que se suba un fragmento de código al proyecto esta aplicación resumirá los distintos fallos encontrados, haciendo distinción entre los ya existentes y los nuevos.

\section{Compilación, instalación y ejecución del proyecto}
\subsection{Ejecución en local}
Para ejecutar la aplicación en local solo es necesario ejecutar la clase principal: Application, los IDEs mencionados previamente los ejecutarán sin problema al ejecutar la opción "Run" y se podrá acceder a dicha aplicación s través de la url: \url{http://localhost:8080/}.
\imagen{EjecucionLocalhost.png}{Ejecución en local}

\section{Pruebas del sistema}
Los test se realizan con JUnit y se han mantenido con respecto a la versión anterior ejecutándose a través del archivo ELearningQAFacadeTest y yendo contra unos archivos estáticos en formato JSON los cuales se encuentran en la ruta "resources/json". Ante las nuevas funcionalidades solo habría que modificar el archivo ELearningQAFacadeTest y asignar unos datos estáticos en el archivo JSON. La opción de obtener los datos de prueba de un servidor de momento es una opción poco viable por el tema del tiempo de carga y el aumento de llamadas en el futuro.